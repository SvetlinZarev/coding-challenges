# [1332. Remove Palindromic Subsequences](https://leetcode.com/problems/remove-palindromic-subsequences/)

## Problem

### Description

You are given a string `s` consisting only of letters `a` and `b`. In a single
step you can remove one palindromic subsequence from `s`.

Return the minimum number of steps to make the given string empty.

A string is a subsequence of a given string if it is generated by deleting some
characters of a given string without changing its order. Note that a subsequence
does not necessarily need to be contiguous.

A string is called palindrome if is one that reads the same backward as well as
forward.

### Constraints

* `1 <= s.length <= 1000`
* `s[i]` is either `a` or `b`

### Examples

```text
Input: s = "ababa"
Output: 1
Explanation: s is already a palindrome, so its entirety can be removed in a single step.
```

```text
Input: s = "abb"
Output: 2
Explanation: "abb" -> "bb" -> "". 
Remove palindromic subsequence "a" then "bb".
```

```text
Input: s = "baabb"
Output: 2
Explanation: "baabb" -> "b" -> "". 
Remove palindromic subsequence "baab" then "b".
```

## Solutions

### Checking if the string is a palindrome

The problem statement makes the question appear harder than it actually is.

We can make the following observations:

* the string is made up of only two characters - `a` and `b`,but may contain
  only 1 of them
* if the string consist of only 1 character - then it's a palindrome
* if the string is a palindrome, then we can remove all of it with one step
* if the string is not a palindrome, then a subsequence of all characters `a`
  forms one palindrome **subsequence**, and all characters `b` form another.

Thus, if the string is a palindrome the number of steps is always 1, and if it
is not a palindrome, then the number of steps is always 2, because we can always
form 2 palindromic subsequences.


```rust
pub fn remove_palindrome_sub<S: AsRef<str>>(s: S) -> i32 {
    let s = s.as_ref().as_bytes();
    if s.len() == 0 {
        return 0;
    }

    let mut l = 0;
    let mut r = s.len() - 1;

    // Check if the string is a palindrome
    while l < r {
        // If it isn't then we can just remove on step 1 all `a` chars,
        // and on step 2 - all `b` chars
        if s[l] != s[r] {
            return 2;
        }

        l += 1;
        r -= 1;
    }

    // The string is a palindrome, so we can remove it with 1 operation - i.e. remove all
    1
}
```
